<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Weather Forecast</title>
    <style>
        :root {
            --bg-color: #ffffff;
            --text-color: #000000;
            --border-color: #cccccc;
            --header-color: #333333;
            --error-color: #cc0000;
        }

        [data-theme="dark"] {
            --bg-color: #1a1a1a;
            --text-color: #e0e0e0;
            --border-color: #444444;
            --header-color: #cccccc;
            --error-color: #ff6666;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.4;
            padding: 20px;
            transition: all 0.2s ease;
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
        }

        .header h1 {
            font-size: 24px;
            color: var(--header-color);
            margin-bottom: 10px;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 5px;
            position: relative;
        }

        .input-container {
            position: relative;
            display: inline-block;
        }

        input[type="text"] {
            background: var(--bg-color);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            padding: 5px 8px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            width: 200px;
        }

        .autocomplete-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--bg-color);
            border: 1px solid var(--border-color);
            border-top: none;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }

        .autocomplete-item {
            padding: 8px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            border-bottom: 1px solid var(--border-color);
        }

        .autocomplete-item:hover,
        .autocomplete-item.selected {
            background: var(--border-color);
        }

        .autocomplete-item:last-child {
            border-bottom: none;
        }

        button {
            background: var(--bg-color);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            padding: 5px 10px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            cursor: pointer;
        }

        button:hover {
            background: var(--border-color);
        }

        .toggle {
            background: none;
            border: none;
            font-size: 18px;
            cursor: pointer;
        }

        .forecast-container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .forecast {
            background: var(--bg-color);
            border: 1px solid var(--border-color);
            padding: 15px;
            white-space: pre;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.3;
        }

        .error {
            color: var(--error-color);
            text-align: center;
            margin: 20px 0;
        }

        .loading {
            text-align: center;
            margin: 20px 0;
            font-style: italic;
        }

        .location-info {
            text-align: center;
            margin-bottom: 15px;
            font-style: italic;
            color: var(--header-color);
        }

        .location-rules {
            text-align: center;
            margin: 10px 0;
            padding: 10px;
            background: var(--bg-color);
            border: 1px solid var(--border-color);
            font-size: 12px;
            line-height: 1.4;
        }

        .location-rules small {
            color: var(--text-color);
        }

        .current-weather {
            text-align: center;
            margin: 20px 0;
            padding: 15px;
            background: var(--bg-color);
            border: 2px solid var(--border-color);
            font-size: 18px;
        }

        .current-temp {
            font-size: 32px;
            font-weight: bold;
            margin: 10px 0;
        }

        .week-calendar {
            display: flex;
            gap: 10px;
            margin: 20px 0;
            overflow-x: hidden;
            padding: 10px 0;
            position: relative;
            cursor: grab;
            transition: transform 0.3s ease;
        }

        .week-calendar:active {
            cursor: grabbing;
        }

        .day-card {
            flex: 1;
            min-width: 120px;
            padding: 15px 10px;
            background: var(--bg-color);
            border: 1px solid var(--border-color);
            cursor: pointer;
            text-align: center;
            transition: all 0.2s ease;
        }

        .day-card:hover {
            background: var(--border-color);
            transform: translateY(-2px);
        }

        .day-card.today {
            border: 2px solid var(--header-color);
            background: var(--border-color);
        }

        .day-card.selected {
            border: 2px solid var(--header-color);
            background: var(--header-color);
            color: var(--bg-color);
        }

        .day-name {
            font-weight: bold;
            margin-bottom: 5px;
        }

        .day-date {
            font-size: 12px;
            margin-bottom: 10px;
            opacity: 0.8;
        }

        .day-weather {
            font-size: 24px;
            margin: 10px 0;
        }

        .day-temps {
            font-size: 14px;
            margin-top: 5px;
        }

        .day-rain {
            font-size: 12px;
            opacity: 0.8;
            margin-top: 5px;
        }

        .hourly-detail {
            margin-top: 20px;
            display: none;
        }

        .hourly-detail.show {
            display: block;
        }

        .hourly-detail h3 {
            text-align: center;
            margin-bottom: 15px;
            color: var(--header-color);
        }

        .hourly-table {
            background: var(--bg-color);
            border: 1px solid var(--border-color);
            padding: 15px;
            white-space: pre;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.3;
        }

        .current-hour {
            background: var(--border-color);
        }

        .forecast-controls {
            text-align: center;
            margin: 20px 0;
        }

        .show-more-btn {
            background: var(--bg-color);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            padding: 8px 16px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            cursor: pointer;
            margin: 0 10px;
        }

        .show-more-btn:hover {
            background: var(--border-color);
        }

        .extended-calendar {
            display: none;
            margin-top: 10px;
        }

        .extended-calendar.show {
            display: flex;
            gap: 10px;
            overflow-x: auto;
            padding: 10px 0;
        }

        @media (max-width: 768px) {
            body {
                padding: 10px;
                font-size: 12px;
            }

            .forecast {
                font-size: 11px;
            }

            input[type="text"] {
                width: 150px;
                font-size: 12px;
            }

            .week-calendar {
                gap: 5px;
            }

            .day-card {
                min-width: 100px;
                padding: 10px 5px;
            }

            .current-weather {
                font-size: 16px;
            }

            .current-temp {
                font-size: 28px;
            }
        }
    </style>
</head>

<body data-theme="light">
    <div class="header">
        <h1>‚õÖ Weather Forecast</h1>
        <div class="controls">
            <div class="control-group">
                <div class="input-container">
                    <input type="text" id="cityInput" placeholder="e.g. Philadelphia, PA, US" autocomplete="off" />
                    <div class="autocomplete-dropdown" id="autocompleteDropdown"></div>
                </div>
                <button onclick="searchCity()">Get Weather</button>
            </div>
            <div class="control-group">
                <button onclick="toggleUnits()" id="unitsBtn">¬∞C</button>
                <button onclick="clearLocationCache()" title="Clear cached location">üìç</button>
                <button class="toggle" onclick="toggleTheme()" id="themeToggle">üåô</button>
            </div>
        </div>
        <div class="location-rules" id="locationRules" style="display: none;">
            <small>
                üìç Location Format Rules:<br>
                ‚úÖ Preferred: "City, State (abbrev), Country (abbrev)" ‚Üí "Harrisburg, PA, US"<br>
                NOTE: Sometimes errors will be made, if so, please choose a city next to your location, for some reason
                the API cannot get the same location twice
            </small>
        </div>
    </div>

    <div class="location-info" id="locationInfo"></div>
    <div class="loading" id="loading">Loading weather data...</div>
    <div class="error" id="error" style="display: none;"></div>

    <div class="current-weather" id="currentWeather" style="display: none;">
        <div>üå°Ô∏è Current Temperature</div>
        <div class="current-temp" id="currentTemp">--¬∞</div>
        <div id="currentCondition">--</div>
    </div>

    <div class="week-calendar" id="weekCalendar" style="display: none;"></div>



    <div class="hourly-detail" id="hourlyDetail">
        <h3 id="selectedDayTitle">Today's Hourly Forecast</h3>
        <pre class="hourly-table" id="hourlyTable"></pre>
    </div>

    <div class="forecast-container">
        <pre class="forecast" id="forecast" style="display: none;"></pre>
    </div>

    <script>
        let currentLat = null;
        let currentLon = null;
        let currentLocation = '';
        let useCelsius = true;
        let weatherData = null;
        let autocompleteTimeout = null;
        let selectedIndex = -1;
        let autocompleteResults = [];
        let selectedDay = 0; // 0 = today
        let showingExtended = false;
        let cachedLocation = null;

        // Weather condition mapping to emojis with day/night variants
        const weatherIcons = {
            day: {
                0: '‚òÄÔ∏è',     // Clear sky (day)
                1: 'üå§Ô∏è',     // Mainly clear (day)
                2: '‚õÖ',     // Partly cloudy (day)
                3: '‚òÅÔ∏è',     // Overcast
                45: 'üå´Ô∏è',    // Fog
                48: 'üå´Ô∏è',    // Depositing rime fog
                51: 'üíß',     // Light drizzle
                53: 'üíß',     // Moderate drizzle
                55: 'üíß',     // Dense drizzle
                56: 'üíßüßä',   // Light freezing drizzle
                57: 'üíßüßä',   // Dense freezing drizzle
                61: 'üåßÔ∏è',    // Slight rain
                63: '‚òî',     // Moderate rain
                65: 'üí¶',     // Heavy rain
                66: 'üåßÔ∏èüßä',  // Light freezing rain
                67: 'üåßÔ∏èüßä',  // Heavy freezing rain
                71: '‚ùÑÔ∏è',     // Slight snow fall
                73: '‚ùÑÔ∏è',     // Moderate snow fall
                75: '‚ùÑÔ∏è',     // Heavy snow fall
                77: '‚ö™',     // Snow grains
                80: 'üå¶Ô∏è',    // Slight rain showers (day)
                81: 'üåßÔ∏è',    // Moderate rain showers
                82: 'üí¶',     // Violent rain showers
                85: 'üå®Ô∏è',    // Slight snow showers
                86: 'üå®Ô∏è',    // Heavy snow showers
                95: '‚õàÔ∏è',     // Thunderstorm (day)
                96: 'üå©Ô∏èüßä',  // Thunderstorm with slight hail
                99: 'üå©Ô∏èüßä'   // Thunderstorm with heavy hail
            },
            night: {
                0: 'üåô',     // Clear sky (night)
                1: 'üåô‚òÅÔ∏è',   // Mainly clear (night)
                2: 'üåô‚òÅÔ∏è',   // Partly cloudy (night)
                3: '‚òÅÔ∏è',     // Overcast
                45: 'üå´Ô∏è',    // Fog
                48: 'üå´Ô∏è',    // Depositing rime fog
                51: 'üíß',     // Light drizzle
                53: 'üíß',     // Moderate drizzle
                55: 'üíß',     // Dense drizzle
                56: 'üíßüßä',   // Light freezing drizzle
                57: 'üíßüßä',   // Dense freezing drizzle
                61: 'üåßÔ∏è',    // Slight rain
                63: '‚òî',     // Moderate rain
                65: 'üí¶',     // Heavy rain
                66: 'üåßÔ∏èüßä',  // Light freezing rain
                67: 'üåßÔ∏èüßä',  // Heavy freezing rain
                71: '‚ùÑÔ∏è',     // Slight snow fall
                73: '‚ùÑÔ∏è',     // Moderate snow fall
                75: '‚ùÑÔ∏è',     // Heavy snow fall
                77: '‚ö™',     // Snow grains
                80: 'üåôüåßÔ∏è',  // Slight rain showers (night)
                81: 'üåßÔ∏è',    // Moderate rain showers
                82: 'üí¶',     // Violent rain showers
                85: 'üå®Ô∏è',    // Slight snow showers
                86: 'üå®Ô∏è',    // Heavy snow showers
                95: 'üåôüå©Ô∏è',  // Thunderstorm (night)
                96: 'üå©Ô∏èüßä',  // Thunderstorm with slight hail
                99: 'üå©Ô∏èüßä'   // Thunderstorm with heavy hail
            }
        };

        // Function to determine if it's day or night based on hour
        function isNightTime(hour) {
            // Simple day/night logic: night is 6 PM to 6 AM (18:00 to 06:00)
            return hour < 6 || hour >= 18;
        }

        // Function to get weather icon based on code and time
        function getWeatherIcon(weatherCode, hour = null) {
            // For daily forecasts (no hour provided), use day icons
            if (hour === null) {
                return weatherIcons.day[weatherCode] || '‚ùì';
            }

            // For hourly forecasts, use day/night variants
            const timeOfDay = isNightTime(hour) ? 'night' : 'day';
            return weatherIcons[timeOfDay][weatherCode] || '‚ùì';
        }

        const weatherDescriptions = {
            0: 'Clear sky',
            1: 'Mainly clear',
            2: 'Partly cloudy',
            3: 'Overcast',
            45: 'Fog',
            48: 'Depositing rime fog',
            51: 'Light drizzle',
            53: 'Moderate drizzle',
            55: 'Dense drizzle',
            56: 'Light freezing drizzle',
            57: 'Dense freezing drizzle',
            61: 'Slight rain',
            63: 'Moderate rain',
            65: 'Heavy rain',
            66: 'Light freezing rain',
            67: 'Heavy freezing rain',
            71: 'Slight snow',
            73: 'Moderate snow',
            75: 'Heavy snow',
            77: 'Snow grains',
            80: 'Slight rain showers',
            81: 'Moderate rain showers',
            82: 'Violent rain showers',
            85: 'Slight snow showers',
            86: 'Heavy snow showers',
            95: 'Thunderstorm',
            96: 'Thunderstorm with hail',
            99: 'Thunderstorm with heavy hail'
        };

        // Initialize on page load
        window.addEventListener('load', () => {
            const urlParams = new URLSearchParams(window.location.search);
            const cityParam = urlParams.get('city');

            if (cityParam) {
                document.getElementById('cityInput').value = cityParam;
                searchCity();
            } else {
                getLocationAndWeather();
            }
        });

        async function getLocationAndWeather() {
            try {
                showLoading('Getting your location...');

                // Check if we have cached location data
                const cached = localStorage.getItem('weatherAppLocation');
                if (cached) {
                    cachedLocation = JSON.parse(cached);
                    currentLat = cachedLocation.lat;
                    currentLon = cachedLocation.lon;
                    currentLocation = cachedLocation.name;
                    await getWeatherData();
                    return;
                }

                // Try browser geolocation first (more accurate)
                if (navigator.geolocation) {
                    try {
                        const position = await new Promise((resolve, reject) => {
                            navigator.geolocation.getCurrentPosition(resolve, reject, {
                                timeout: 10000,
                                enableHighAccuracy: true
                            });
                        });

                        currentLat = position.coords.latitude;
                        currentLon = position.coords.longitude;

                        // Get location name from coordinates
                        const reverseGeoResponse = await fetch(
                            `https://nominatim.openstreetmap.org/reverse?format=json&lat=${currentLat}&lon=${currentLon}&addressdetails=1`
                        );
                        const reverseGeoData = await reverseGeoResponse.json();

                        if (reverseGeoData.address) {
                            const addr = reverseGeoData.address;
                            currentLocation = formatLocationFromAddress(addr);
                        } else {
                            currentLocation = `${currentLat.toFixed(2)}, ${currentLon.toFixed(2)}`;
                        }

                        // Cache the location
                        const locationData = {
                            lat: currentLat,
                            lon: currentLon,
                            name: currentLocation,
                            timestamp: Date.now()
                        };
                        localStorage.setItem('weatherAppLocation', JSON.stringify(locationData));

                        await getWeatherData();
                        return;
                    } catch (geoError) {
                        console.log('Browser geolocation failed, trying IP geolocation:', geoError);
                    }
                }

                // Fallback to IP-based geolocation
                const ipResponse = await fetch('https://ipapi.co/json/');
                const ipData = await ipResponse.json();

                if (ipData.latitude && ipData.longitude) {
                    currentLat = ipData.latitude;
                    currentLon = ipData.longitude;
                    currentLocation = `${ipData.city}, ${ipData.region}`;

                    // Cache the IP location
                    const locationData = {
                        lat: currentLat,
                        lon: currentLon,
                        name: currentLocation,
                        timestamp: Date.now()
                    };
                    localStorage.setItem('weatherAppLocation', JSON.stringify(locationData));

                    await getWeatherData();
                } else {
                    throw new Error('Could not determine location');
                }
            } catch (error) {
                console.error('Location detection failed:', error);
                showError('Could not auto-detect location. Please enter a city name manually.');
            }
        }

        function formatLocationFromAddress(addr) {
            let location = '';

            if (addr.city || addr.town || addr.village) {
                location += addr.city || addr.town || addr.village;
            } else if (addr.county) {
                location += addr.county;
            }

            if (addr.state) {
                location += location ? ', ' + addr.state : addr.state;
            }

            if (addr.country_code) {
                location += location ? ', ' + addr.country_code.toUpperCase() : addr.country_code.toUpperCase();
            }

            return location || 'Unknown Location';
        }

        async function searchCity() {
            const city = document.getElementById('cityInput').value.trim();
            if (!city) return;

            // Validate location format
            const validationResult = validateLocationFormat(city);
            if (!validationResult.valid) {
                showLocationRules();
                showError(validationResult.message);
                return;
            }

            try {
                showLoading(`Getting weather for ${city}...`);
                hideLocationRules();

                // Use Open-Meteo geocoding API
                const geocodeResponse = await fetch(
                    `https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(city)}&count=1`
                );
                const geocodeData = await geocodeResponse.json();

                if (!geocodeData.results || geocodeData.results.length === 0) {
                    throw new Error('City not found. Please check the format rules below.');
                }

                const location = geocodeData.results[0];
                currentLat = location.latitude;
                currentLon = location.longitude;
                currentLocation = `${location.name}${location.admin1 ? ', ' + location.admin1 : ''}, ${location.country}`;

                // Update URL
                const url = new URL(window.location);
                url.searchParams.set('city', city);
                window.history.replaceState({}, '', url);

                await getWeatherData();
            } catch (error) {
                showLocationRules();
                showError(`Error getting weather for "${city}": ${error.message}`);
            }
        }

        function validateLocationFormat(input) {
            const trimmed = input.trim();

            // Too vague patterns
            const tooVague = [
                /^(us|usa|united states)$/i,
                /^(uk|united kingdom|britain)$/i,
                /^(ca|canada)$/i,
                /^(north america|south america|europe|asia|africa|australia|antarctica)$/i
            ];

            for (const pattern of tooVague) {
                if (pattern.test(trimmed)) {
                    return {
                        valid: false,
                        message: `"${trimmed}" is too vague. Please be more specific (e.g., "Boston, MA, US").`
                    };
                }
            }

            // State abbreviation pattern (acceptable shorthand)
            const stateAbbrev = /^[A-Z]{2}$/;
            if (stateAbbrev.test(trimmed)) {
                return { valid: true };
            }

            // Preferred format: City, State, Country
            const preferredFormat = /^[^,]+,\s*[^,]+,\s*[^,]+$/;
            if (preferredFormat.test(trimmed)) {
                return { valid: true };
            }

            // City, Country format (acceptable)
            const cityCountry = /^[^,]+,\s*[^,]+$/;
            if (cityCountry.test(trimmed)) {
                return { valid: true };
            }

            // Single city name (acceptable but less precise)
            if (trimmed.length > 2 && !trimmed.includes(',')) {
                return { valid: true };
            }

            return { valid: true }; // Allow other formats to pass through
        }

        function showLocationRules() {
            document.getElementById('locationRules').style.display = 'block';
        }

        function hideLocationRules() {
            document.getElementById('locationRules').style.display = 'none';
        }

        async function getWeatherData() {
            try {
                const response = await fetch(
                    `https://api.open-meteo.com/v1/forecast?latitude=${currentLat}&longitude=${currentLon}&hourly=temperature_2m,relative_humidity_2m,precipitation_probability,weather_code,uv_index&daily=weather_code,temperature_2m_max,temperature_2m_min,precipitation_probability_max&timezone=auto&forecast_days=14`
                );

                if (!response.ok) {
                    throw new Error('Weather API request failed');
                }

                weatherData = await response.json();
                displayWeatherCalendar();
            } catch (error) {
                showError(`Error fetching weather data: ${error.message}`);
            }
        }

        function displayWeatherCalendar() {
            if (!weatherData) return;

            document.getElementById('locationInfo').textContent = `Weather for ${currentLocation}`;

            // Show current temperature
            displayCurrentWeather();

            // Show 7-day calendar
            displayWeekCalendar();

            // Show today's hourly forecast by default
            displayHourlyForecast(0);

            // Hide old forecast and show new layout
            document.getElementById('forecast').style.display = 'none';
            document.getElementById('currentWeather').style.display = 'block';
            document.getElementById('weekCalendar').style.display = 'flex';
            document.getElementById('hourlyDetail').style.display = 'block';
            document.getElementById('loading').style.display = 'none';
            document.getElementById('error').style.display = 'none';

            // Initialize auto-scroll for the calendar
            setTimeout(initAutoScroll, 100);
        }

        function displayCurrentWeather() {
            const hourly = weatherData.hourly;
            const now = new Date();

            // Find current hour index
            let currentHourIndex = 0;
            for (let i = 0; i < hourly.time.length; i++) {
                const hourTime = new Date(hourly.time[i]);
                if (hourTime <= now) {
                    currentHourIndex = i;
                } else {
                    break;
                }
            }

            const currentTemp = hourly.temperature_2m[currentHourIndex];
            const currentWeatherCode = hourly.weather_code[currentHourIndex];

            const tempDisplay = useCelsius ?
                Math.round(currentTemp) + '¬∞C' :
                Math.round(currentTemp * 9 / 5 + 32) + '¬∞F';

            const currentHour = now.getHours();
            const icon = getWeatherIcon(currentWeatherCode, currentHour);
            const description = weatherDescriptions[currentWeatherCode] || 'Unknown';

            document.getElementById('currentTemp').textContent = tempDisplay;
            document.getElementById('currentCondition').textContent = `${icon} ${description}`;
        }

        function displayWeekCalendar() {
            const daily = weatherData.daily;
            const calendar = document.getElementById('weekCalendar');
            calendar.innerHTML = '';

            const today = new Date();
            today.setHours(0, 0, 0, 0); // Reset time for accurate comparison
            const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];

            // Find today's index in the API data
            let todayIndex = -1;
            for (let i = 0; i < daily.time.length; i++) {
                const date = new Date(daily.time[i]);
                date.setHours(0, 0, 0, 0);
                if (date.getTime() === today.getTime()) {
                    todayIndex = i;
                    break;
                }
            }

            // Debug logging
            console.log('Today:', today.toDateString());
            console.log('API dates:', daily.time.slice(0, 3).map(t => new Date(t).toDateString()));
            console.log('Today index in API:', todayIndex);

            // If today not found, start from first available day
            const startIndex = todayIndex >= 0 ? todayIndex : 0;
            console.log('Start index:', startIndex);

            // Display all 14 days starting from today
            for (let i = 0; i < 14 && (startIndex + i) < daily.time.length; i++) {
                const dataIndex = startIndex + i;
                const date = new Date(daily.time[dataIndex]);
                date.setHours(0, 0, 0, 0);

                // Check if this is actually today by comparing the actual dates
                const isToday = date.getTime() === today.getTime();

                const dayCard = document.createElement('div');
                dayCard.className = `day-card ${isToday ? 'today' : ''}`;
                dayCard.onclick = () => selectDay(dataIndex);

                // Use the actual date for day name calculation
                const dayName = isToday ? 'Today' : dayNames[date.getDay()];
                const dayDate = date.toLocaleDateString('en', { month: 'short', day: 'numeric' });

                const weatherCode = daily.weather_code[dataIndex];
                const icon = getWeatherIcon(weatherCode); // Daily forecast, use day icons

                const maxTemp = useCelsius ?
                    Math.round(daily.temperature_2m_max[dataIndex]) :
                    Math.round(daily.temperature_2m_max[dataIndex] * 9 / 5 + 32);
                const minTemp = useCelsius ?
                    Math.round(daily.temperature_2m_min[dataIndex]) :
                    Math.round(daily.temperature_2m_min[dataIndex] * 9 / 5 + 32);

                const rainChance = Math.round(daily.precipitation_probability_max[dataIndex]);
                const unit = useCelsius ? '¬∞C' : '¬∞F';

                dayCard.innerHTML = `
                    <div class="day-name">${dayName}</div>
                    <div class="day-date">${dayDate}</div>
                    <div class="day-weather">${icon}</div>
                    <div class="day-temps">${maxTemp}¬∞ / ${minTemp}¬∞${unit}</div>
                    <div class="day-rain">${rainChance}% rain</div>
                `;

                calendar.appendChild(dayCard);
            }

            // Select today by default (first card in the calendar)
            // The first card always represents startIndex in the API data
            // Use setTimeout to ensure DOM is fully updated
            setTimeout(() => {
                selectDay(startIndex);
            }, 10);
        }



        function clearLocationCache() {
            localStorage.removeItem('weatherAppLocation');
            cachedLocation = null;
            alert('Location cache cleared. Refresh the page to detect location again.');
        }

        function selectDay(dayIndex) {
            selectedDay = dayIndex;

            // Update visual selection for the calendar
            const dayCards = document.querySelectorAll('#weekCalendar .day-card');

            // Remove selection from all cards
            dayCards.forEach(card => card.classList.remove('selected'));

            // Find which card to select based on the data index
            const today = new Date();
            today.setHours(0, 0, 0, 0);

            let todayIndex = -1;
            for (let i = 0; i < weatherData.daily.time.length; i++) {
                const date = new Date(weatherData.daily.time[i]);
                date.setHours(0, 0, 0, 0);
                if (date.getTime() === today.getTime()) {
                    todayIndex = i;
                    break;
                }
            }

            const startIndex = todayIndex >= 0 ? todayIndex : 0;

            // Select the appropriate card
            const cardIndex = dayIndex - startIndex;
            if (dayCards[cardIndex]) {
                dayCards[cardIndex].classList.add('selected');
            }

            // Display hourly forecast for selected day
            displayHourlyForecast(dayIndex);
        }

        function displayHourlyForecast(dayIndex) {
            const hourly = weatherData.hourly;
            const selectedDate = new Date(weatherData.daily.time[dayIndex]);
            const now = new Date();

            // Ensure we have valid data
            if (!weatherData.daily.time[dayIndex]) {
                console.error('Invalid dayIndex:', dayIndex, 'Available days:', weatherData.daily.time.length);
                return;
            }

            // Find hours for the selected day
            const dayHours = [];
            for (let i = 0; i < hourly.time.length; i++) {
                const hourTime = new Date(hourly.time[i]);
                if (hourTime.toDateString() === selectedDate.toDateString()) {
                    dayHours.push({
                        index: i,
                        time: hourTime,
                        temp: hourly.temperature_2m[i],
                        humidity: hourly.relative_humidity_2m[i],
                        precipitation: hourly.precipitation_probability[i],
                        weatherCode: hourly.weather_code[i],
                        uvIndex: hourly.uv_index[i] || 0
                    });
                }
            }

            // If no hours found, it might be a date mismatch issue
            if (dayHours.length === 0) {
                console.warn('No hourly data found for date:', selectedDate.toDateString());
                console.warn('Available hourly dates:', hourly.time.slice(0, 5).map(t => new Date(t).toDateString()));
            }

            // Check if selected day is actually today by comparing dates
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            selectedDate.setHours(0, 0, 0, 0);
            const isActuallyToday = selectedDate.getTime() === today.getTime();

            const dayName = isActuallyToday ? 'Today' : selectedDate.toLocaleDateString('en', { weekday: 'long', month: 'short', day: 'numeric' });
            document.getElementById('selectedDayTitle').textContent = `${dayName}'s Hourly Forecast`;

            let output = `HOURLY FORECAST - ${dayName.toUpperCase()}\n`;
            output += `${'='.repeat(80)}\n\n`;
            output += `üìç Location: ${currentLocation}\n`;
            output += `üïê Updated: ${now.toLocaleString()}\n`;
            output += `${'‚îÄ'.repeat(80)}\n\n`;

            // Header
            output += `Time   Weather    Temp   Humidity  Rain%  UV   Description\n`;
            output += `${'‚îÄ'.repeat(80)}\n`;

            const currentHour = now.getHours();
            const isToday = isActuallyToday;

            dayHours.forEach(hour => {
                const timeStr = hour.time.getHours().toString().padStart(2, '0') + ':00';
                const weatherCode = hour.weatherCode;
                const hourOfDay = hour.time.getHours();
                const icon = getWeatherIcon(weatherCode, hourOfDay);
                const temp = useCelsius ?
                    Math.round(hour.temp) + '¬∞C' :
                    Math.round(hour.temp * 9 / 5 + 32) + '¬∞F';
                const humidity = Math.round(hour.humidity) + '%';
                const precipitation = Math.round(hour.precipitation) + '%';
                const uvIndex = Math.round(hour.uvIndex);
                const description = weatherDescriptions[weatherCode] || 'Unknown';

                const timeDisplay = timeStr.padEnd(7);
                const weatherDisplay = `${icon}`.padEnd(10);
                const tempDisplay = temp.padEnd(7);
                const humidityDisplay = humidity.padEnd(9);
                const rainDisplay = precipitation.padEnd(7);
                const uvDisplay = uvIndex.toString().padEnd(5);

                // Highlight current hour if it's today
                const isCurrentHour = isToday && hour.time.getHours() === currentHour;
                const prefix = isCurrentHour ? '‚Üí ' : '  ';

                output += `${prefix}${timeDisplay}${weatherDisplay}${tempDisplay}${humidityDisplay}${rainDisplay}${uvDisplay}${description}\n`;
            });

            output += `\n${'‚îÄ'.repeat(80)}\n`;
            output += `üå°Ô∏è  Temperature in ${useCelsius ? 'Celsius' : 'Fahrenheit'}\n`;
            output += `üíß Humidity shows relative humidity percentage\n`;
            output += `üåßÔ∏è  Rain% shows probability of precipitation\n`;
            output += `‚òÄÔ∏è  UV Index: 0-2 Low, 3-5 Moderate, 6-7 High, 8-10 Very High, 11+ Extreme\n`;
            if (isToday) {
                output += `‚û°Ô∏è  Arrow (‚Üí) indicates current hour\n`;
            }

            document.getElementById('hourlyTable').textContent = output;
        }

        function toggleUnits() {
            useCelsius = !useCelsius;
            document.getElementById('unitsBtn').textContent = useCelsius ? '¬∞C' : '¬∞F';
            if (weatherData) {
                displayWeatherCalendar();
            }
        }

        function toggleTheme() {
            const body = document.body;
            const themeToggle = document.getElementById('themeToggle');

            if (body.getAttribute('data-theme') === 'light') {
                body.setAttribute('data-theme', 'dark');
                themeToggle.textContent = '‚òÄÔ∏è';
            } else {
                body.setAttribute('data-theme', 'light');
                themeToggle.textContent = 'üåô';
            }
        }

        function showLoading(message) {
            document.getElementById('loading').textContent = message;
            document.getElementById('loading').style.display = 'block';
            document.getElementById('forecast').style.display = 'none';
            document.getElementById('currentWeather').style.display = 'none';
            document.getElementById('weekCalendar').style.display = 'none';
            document.getElementById('hourlyDetail').style.display = 'none';
            document.getElementById('error').style.display = 'none';
        }

        function showError(message) {
            document.getElementById('error').textContent = message;
            document.getElementById('error').style.display = 'block';
            document.getElementById('loading').style.display = 'none';
            document.getElementById('forecast').style.display = 'none';
            document.getElementById('currentWeather').style.display = 'none';
            document.getElementById('weekCalendar').style.display = 'none';
            document.getElementById('hourlyDetail').style.display = 'none';
        }

        // Autocomplete functionality
        async function searchLocations(query) {
            if (query.length < 2) {
                hideAutocomplete();
                return;
            }

            try {
                // Use Nominatim (OpenStreetMap) geocoding API
                const response = await fetch(
                    `https://nominatim.openstreetmap.org/search?format=json&limit=5&q=${encodeURIComponent(query)}&addressdetails=1`
                );
                const results = await response.json();

                autocompleteResults = results.map(result => ({
                    display: formatLocationDisplay(result),
                    lat: parseFloat(result.lat),
                    lon: parseFloat(result.lon),
                    name: result.display_name
                }));

                showAutocomplete(autocompleteResults);
            } catch (error) {
                console.error('Autocomplete search failed:', error);
                hideAutocomplete();
            }
        }

        function formatLocationDisplay(result) {
            const addr = result.address || {};
            let display = '';

            // Try to build a nice display format
            if (addr.city || addr.town || addr.village) {
                display += addr.city || addr.town || addr.village;
            } else if (addr.county) {
                display += addr.county;
            }

            if (addr.state) {
                display += display ? ', ' + addr.state : addr.state;
            }

            if (addr.country_code) {
                display += display ? ', ' + addr.country_code.toUpperCase() : addr.country_code.toUpperCase();
            }

            return display || result.display_name;
        }

        function showAutocomplete(results) {
            const dropdown = document.getElementById('autocompleteDropdown');
            dropdown.innerHTML = '';

            if (results.length === 0) {
                hideAutocomplete();
                return;
            }

            results.forEach((result, index) => {
                const item = document.createElement('div');
                item.className = 'autocomplete-item';
                item.textContent = result.display;
                item.addEventListener('click', () => selectLocation(result));
                dropdown.appendChild(item);
            });

            dropdown.style.display = 'block';
            selectedIndex = -1;
        }

        function hideAutocomplete() {
            document.getElementById('autocompleteDropdown').style.display = 'none';
            selectedIndex = -1;
        }

        function selectLocation(location) {
            document.getElementById('cityInput').value = location.display;
            currentLat = location.lat;
            currentLon = location.lon;
            currentLocation = location.display;
            hideAutocomplete();

            // Update URL
            const url = new URL(window.location);
            url.searchParams.set('city', location.display);
            window.history.replaceState({}, '', url);

            // Get weather immediately
            getWeatherData();
        }

        function navigateAutocomplete(direction) {
            const items = document.querySelectorAll('.autocomplete-item');
            if (items.length === 0) return;

            // Remove previous selection
            if (selectedIndex >= 0) {
                items[selectedIndex].classList.remove('selected');
            }

            // Update selection
            if (direction === 'down') {
                selectedIndex = selectedIndex < items.length - 1 ? selectedIndex + 1 : 0;
            } else if (direction === 'up') {
                selectedIndex = selectedIndex > 0 ? selectedIndex - 1 : items.length - 1;
            }

            // Apply new selection
            items[selectedIndex].classList.add('selected');
        }

        // Event listeners
        document.getElementById('cityInput').addEventListener('input', function () {
            const query = this.value.trim();

            if (query) {
                hideLocationRules();

                // Debounce the search
                clearTimeout(autocompleteTimeout);
                autocompleteTimeout = setTimeout(() => {
                    searchLocations(query);
                }, 300);
            } else {
                hideAutocomplete();
            }
        });

        document.getElementById('cityInput').addEventListener('keydown', function (e) {
            const dropdown = document.getElementById('autocompleteDropdown');

            if (dropdown.style.display === 'block') {
                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    navigateAutocomplete('down');
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    navigateAutocomplete('up');
                } else if (e.key === 'Enter') {
                    e.preventDefault();
                    if (selectedIndex >= 0 && autocompleteResults[selectedIndex]) {
                        selectLocation(autocompleteResults[selectedIndex]);
                    } else {
                        searchCity();
                    }
                } else if (e.key === 'Escape') {
                    hideAutocomplete();
                }
            } else if (e.key === 'Enter') {
                searchCity();
            }
        });

        // Hide autocomplete when clicking outside
        document.addEventListener('click', function (e) {
            if (!e.target.closest('.input-container')) {
                hideAutocomplete();
            }
        });

        // Auto-scroll functionality for the calendar
        let scrollPosition = 0;
        let isScrolling = false;
        let scrollAnimation = null;

        function initAutoScroll() {
            const calendar = document.getElementById('weekCalendar');
            if (!calendar) return;

            // Use document-level mouse tracking for edge-to-edge detection
            document.addEventListener('mousemove', function (e) {
                const rect = calendar.getBoundingClientRect();
                const calendarTop = rect.top;
                const calendarBottom = rect.bottom;
                const mouseY = e.clientY;

                // Only scroll when mouse is within the calendar's vertical bounds
                if (mouseY < calendarTop || mouseY > calendarBottom) return;

                // Use full screen width for edge-to-edge detection
                const screenWidth = window.innerWidth;
                const mouseX = e.clientX-30; // Mouse position relative to screen edge I DID THE 30 AND SMH IT WORKS?
                const scrollableWidth = calendar.scrollWidth;
                const containerWidth = rect.width;
                const maxScroll = scrollableWidth - containerWidth;

                if (maxScroll <= 0) return; // No need to scroll if content fits

                // Calculate scroll position based on screen mouse position
                // Mouse at screen left edge (0) = scroll position 0
                // Mouse at screen right edge (screenWidth) = scroll position maxScroll
                const targetScroll = (mouseX / screenWidth) * 1.2*maxScroll; // I DID THE 1.2 and SMH IT WORKS

                // Smooth scroll to target position
                if (!isScrolling) {
                    isScrolling = true;
                    smoothScrollTo(calendar, targetScroll);
                }
            });
        }

        function smoothScrollTo(element, targetScroll) {
            if (scrollAnimation) {
                cancelAnimationFrame(scrollAnimation);
            }

            const startScroll = element.scrollLeft;
            const distance = targetScroll - startScroll;
            const duration = 270; // ms (1.1x faster: 300/1.1 ‚âà 273, rounded to 270)
            let startTime = null;

            function animate(currentTime) {
                if (startTime === null) startTime = currentTime;
                const timeElapsed = currentTime - startTime;
                const progress = Math.min(timeElapsed / duration, 1);

                // Easing function for smooth animation
                const easeProgress = 1 - Math.pow(1 - progress, 3);

                element.scrollLeft = startScroll + (distance * easeProgress);

                if (progress < 1) {
                    scrollAnimation = requestAnimationFrame(animate);
                } else {
                    isScrolling = false;
                    scrollAnimation = null;
                }
            }

            scrollAnimation = requestAnimationFrame(animate);
        }

        // Initialize auto-scroll when the calendar is displayed
        document.addEventListener('DOMContentLoaded', function () {
            // Wait a bit for the calendar to be populated
            setTimeout(initAutoScroll, 500);
        });
    </script>
</body>

</html>
